// This file is generated by rust-protobuf 3.5.0. Do not edit
// .proto file is parsed by protoc --rust_out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `stormgate.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_5_0;

///  Each chunk seems to be of the form 3: {1: {actual content}}
///  Since I don't know the meaning of those outer structs yet, I'm just putting them as inline messages:
// @@protoc_insertion_point(message:stormgate.ReplayChunk)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ReplayChunk {
    // message fields
    // @@protoc_insertion_point(field:stormgate.ReplayChunk.timestamp)
    pub timestamp: i32,
    // @@protoc_insertion_point(field:stormgate.ReplayChunk.client_id)
    pub client_id: i32,
    // @@protoc_insertion_point(field:stormgate.ReplayChunk.inner)
    pub inner: ::protobuf::MessageField<replay_chunk::Wrapper>,
    // special fields
    // @@protoc_insertion_point(special_field:stormgate.ReplayChunk.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReplayChunk {
    fn default() -> &'a ReplayChunk {
        <ReplayChunk as ::protobuf::Message>::default_instance()
    }
}

impl ReplayChunk {
    pub fn new() -> ReplayChunk {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "timestamp",
            |m: &ReplayChunk| { &m.timestamp },
            |m: &mut ReplayChunk| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "client_id",
            |m: &ReplayChunk| { &m.client_id },
            |m: &mut ReplayChunk| { &mut m.client_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, replay_chunk::Wrapper>(
            "inner",
            |m: &ReplayChunk| { &m.inner },
            |m: &mut ReplayChunk| { &mut m.inner },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReplayChunk>(
            "ReplayChunk",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReplayChunk {
    const NAME: &'static str = "ReplayChunk";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.timestamp = is.read_int32()?;
                },
                16 => {
                    self.client_id = is.read_int32()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.inner)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.timestamp);
        }
        if self.client_id != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.client_id);
        }
        if let Some(v) = self.inner.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.timestamp != 0 {
            os.write_int32(1, self.timestamp)?;
        }
        if self.client_id != 0 {
            os.write_int32(2, self.client_id)?;
        }
        if let Some(v) = self.inner.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReplayChunk {
        ReplayChunk::new()
    }

    fn clear(&mut self) {
        self.timestamp = 0;
        self.client_id = 0;
        self.inner.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReplayChunk {
        static instance: ReplayChunk = ReplayChunk {
            timestamp: 0,
            client_id: 0,
            inner: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReplayChunk {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReplayChunk").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReplayChunk {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReplayChunk {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ReplayChunk`
pub mod replay_chunk {
    // @@protoc_insertion_point(message:stormgate.ReplayChunk.Wrapper)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Wrapper {
        // message fields
        // @@protoc_insertion_point(field:stormgate.ReplayChunk.Wrapper.content)
        pub content: ::protobuf::MessageField<wrapper::ReplayContent>,
        // special fields
        // @@protoc_insertion_point(special_field:stormgate.ReplayChunk.Wrapper.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Wrapper {
        fn default() -> &'a Wrapper {
            <Wrapper as ::protobuf::Message>::default_instance()
        }
    }

    impl Wrapper {
        pub fn new() -> Wrapper {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, wrapper::ReplayContent>(
                "content",
                |m: &Wrapper| { &m.content },
                |m: &mut Wrapper| { &mut m.content },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Wrapper>(
                "ReplayChunk.Wrapper",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Wrapper {
        const NAME: &'static str = "Wrapper";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.content)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.content.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.content.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Wrapper {
            Wrapper::new()
        }

        fn clear(&mut self) {
            self.content.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Wrapper {
            static instance: Wrapper = Wrapper {
                content: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Wrapper {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ReplayChunk.Wrapper").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Wrapper {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Wrapper {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Wrapper`
    pub mod wrapper {
        // @@protoc_insertion_point(message:stormgate.ReplayChunk.Wrapper.ReplayContent)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct ReplayContent {
            // message oneof groups
            pub content_type: ::std::option::Option<replay_content::Content_type>,
            // special fields
            // @@protoc_insertion_point(special_field:stormgate.ReplayChunk.Wrapper.ReplayContent.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a ReplayContent {
            fn default() -> &'a ReplayContent {
                <ReplayContent as ::protobuf::Message>::default_instance()
            }
        }

        impl ReplayContent {
            pub fn new() -> ReplayContent {
                ::std::default::Default::default()
            }

            // .stormgate.MapDetails map_details = 3;

            pub fn map_details(&self) -> &super::super::MapDetails {
                match self.content_type {
                    ::std::option::Option::Some(replay_content::Content_type::MapDetails(ref v)) => v,
                    _ => <super::super::MapDetails as ::protobuf::Message>::default_instance(),
                }
            }

            pub fn clear_map_details(&mut self) {
                self.content_type = ::std::option::Option::None;
            }

            pub fn has_map_details(&self) -> bool {
                match self.content_type {
                    ::std::option::Option::Some(replay_content::Content_type::MapDetails(..)) => true,
                    _ => false,
                }
            }

            // Param is passed by value, moved
            pub fn set_map_details(&mut self, v: super::super::MapDetails) {
                self.content_type = ::std::option::Option::Some(replay_content::Content_type::MapDetails(v))
            }

            // Mutable pointer to the field.
            pub fn mut_map_details(&mut self) -> &mut super::super::MapDetails {
                if let ::std::option::Option::Some(replay_content::Content_type::MapDetails(_)) = self.content_type {
                } else {
                    self.content_type = ::std::option::Option::Some(replay_content::Content_type::MapDetails(super::super::MapDetails::new()));
                }
                match self.content_type {
                    ::std::option::Option::Some(replay_content::Content_type::MapDetails(ref mut v)) => v,
                    _ => panic!(),
                }
            }

            // Take field
            pub fn take_map_details(&mut self) -> super::super::MapDetails {
                if self.has_map_details() {
                    match self.content_type.take() {
                        ::std::option::Option::Some(replay_content::Content_type::MapDetails(v)) => v,
                        _ => panic!(),
                    }
                } else {
                    super::super::MapDetails::new()
                }
            }

            // .stormgate.ClientConnected client_connected = 4;

            pub fn client_connected(&self) -> &super::super::ClientConnected {
                match self.content_type {
                    ::std::option::Option::Some(replay_content::Content_type::ClientConnected(ref v)) => v,
                    _ => <super::super::ClientConnected as ::protobuf::Message>::default_instance(),
                }
            }

            pub fn clear_client_connected(&mut self) {
                self.content_type = ::std::option::Option::None;
            }

            pub fn has_client_connected(&self) -> bool {
                match self.content_type {
                    ::std::option::Option::Some(replay_content::Content_type::ClientConnected(..)) => true,
                    _ => false,
                }
            }

            // Param is passed by value, moved
            pub fn set_client_connected(&mut self, v: super::super::ClientConnected) {
                self.content_type = ::std::option::Option::Some(replay_content::Content_type::ClientConnected(v))
            }

            // Mutable pointer to the field.
            pub fn mut_client_connected(&mut self) -> &mut super::super::ClientConnected {
                if let ::std::option::Option::Some(replay_content::Content_type::ClientConnected(_)) = self.content_type {
                } else {
                    self.content_type = ::std::option::Option::Some(replay_content::Content_type::ClientConnected(super::super::ClientConnected::new()));
                }
                match self.content_type {
                    ::std::option::Option::Some(replay_content::Content_type::ClientConnected(ref mut v)) => v,
                    _ => panic!(),
                }
            }

            // Take field
            pub fn take_client_connected(&mut self) -> super::super::ClientConnected {
                if self.has_client_connected() {
                    match self.content_type.take() {
                        ::std::option::Option::Some(replay_content::Content_type::ClientConnected(v)) => v,
                        _ => panic!(),
                    }
                } else {
                    super::super::ClientConnected::new()
                }
            }

            // .stormgate.Player player = 12;

            pub fn player(&self) -> &super::super::Player {
                match self.content_type {
                    ::std::option::Option::Some(replay_content::Content_type::Player(ref v)) => v,
                    _ => <super::super::Player as ::protobuf::Message>::default_instance(),
                }
            }

            pub fn clear_player(&mut self) {
                self.content_type = ::std::option::Option::None;
            }

            pub fn has_player(&self) -> bool {
                match self.content_type {
                    ::std::option::Option::Some(replay_content::Content_type::Player(..)) => true,
                    _ => false,
                }
            }

            // Param is passed by value, moved
            pub fn set_player(&mut self, v: super::super::Player) {
                self.content_type = ::std::option::Option::Some(replay_content::Content_type::Player(v))
            }

            // Mutable pointer to the field.
            pub fn mut_player(&mut self) -> &mut super::super::Player {
                if let ::std::option::Option::Some(replay_content::Content_type::Player(_)) = self.content_type {
                } else {
                    self.content_type = ::std::option::Option::Some(replay_content::Content_type::Player(super::super::Player::new()));
                }
                match self.content_type {
                    ::std::option::Option::Some(replay_content::Content_type::Player(ref mut v)) => v,
                    _ => panic!(),
                }
            }

            // Take field
            pub fn take_player(&mut self) -> super::super::Player {
                if self.has_player() {
                    match self.content_type.take() {
                        ::std::option::Option::Some(replay_content::Content_type::Player(v)) => v,
                        _ => panic!(),
                    }
                } else {
                    super::super::Player::new()
                }
            }

            // .stormgate.LobbyChangeSlot change_slot = 13;

            pub fn change_slot(&self) -> &super::super::LobbyChangeSlot {
                match self.content_type {
                    ::std::option::Option::Some(replay_content::Content_type::ChangeSlot(ref v)) => v,
                    _ => <super::super::LobbyChangeSlot as ::protobuf::Message>::default_instance(),
                }
            }

            pub fn clear_change_slot(&mut self) {
                self.content_type = ::std::option::Option::None;
            }

            pub fn has_change_slot(&self) -> bool {
                match self.content_type {
                    ::std::option::Option::Some(replay_content::Content_type::ChangeSlot(..)) => true,
                    _ => false,
                }
            }

            // Param is passed by value, moved
            pub fn set_change_slot(&mut self, v: super::super::LobbyChangeSlot) {
                self.content_type = ::std::option::Option::Some(replay_content::Content_type::ChangeSlot(v))
            }

            // Mutable pointer to the field.
            pub fn mut_change_slot(&mut self) -> &mut super::super::LobbyChangeSlot {
                if let ::std::option::Option::Some(replay_content::Content_type::ChangeSlot(_)) = self.content_type {
                } else {
                    self.content_type = ::std::option::Option::Some(replay_content::Content_type::ChangeSlot(super::super::LobbyChangeSlot::new()));
                }
                match self.content_type {
                    ::std::option::Option::Some(replay_content::Content_type::ChangeSlot(ref mut v)) => v,
                    _ => panic!(),
                }
            }

            // Take field
            pub fn take_change_slot(&mut self) -> super::super::LobbyChangeSlot {
                if self.has_change_slot() {
                    match self.content_type.take() {
                        ::std::option::Option::Some(replay_content::Content_type::ChangeSlot(v)) => v,
                        _ => panic!(),
                    }
                } else {
                    super::super::LobbyChangeSlot::new()
                }
            }

            // .stormgate.LobbySetVariable set_variable = 15;

            pub fn set_variable(&self) -> &super::super::LobbySetVariable {
                match self.content_type {
                    ::std::option::Option::Some(replay_content::Content_type::SetVariable(ref v)) => v,
                    _ => <super::super::LobbySetVariable as ::protobuf::Message>::default_instance(),
                }
            }

            pub fn clear_set_variable(&mut self) {
                self.content_type = ::std::option::Option::None;
            }

            pub fn has_set_variable(&self) -> bool {
                match self.content_type {
                    ::std::option::Option::Some(replay_content::Content_type::SetVariable(..)) => true,
                    _ => false,
                }
            }

            // Param is passed by value, moved
            pub fn set_set_variable(&mut self, v: super::super::LobbySetVariable) {
                self.content_type = ::std::option::Option::Some(replay_content::Content_type::SetVariable(v))
            }

            // Mutable pointer to the field.
            pub fn mut_set_variable(&mut self) -> &mut super::super::LobbySetVariable {
                if let ::std::option::Option::Some(replay_content::Content_type::SetVariable(_)) = self.content_type {
                } else {
                    self.content_type = ::std::option::Option::Some(replay_content::Content_type::SetVariable(super::super::LobbySetVariable::new()));
                }
                match self.content_type {
                    ::std::option::Option::Some(replay_content::Content_type::SetVariable(ref mut v)) => v,
                    _ => panic!(),
                }
            }

            // Take field
            pub fn take_set_variable(&mut self) -> super::super::LobbySetVariable {
                if self.has_set_variable() {
                    match self.content_type.take() {
                        ::std::option::Option::Some(replay_content::Content_type::SetVariable(v)) => v,
                        _ => panic!(),
                    }
                } else {
                    super::super::LobbySetVariable::new()
                }
            }

            // .stormgate.StartGame start_game = 18;

            pub fn start_game(&self) -> &super::super::StartGame {
                match self.content_type {
                    ::std::option::Option::Some(replay_content::Content_type::StartGame(ref v)) => v,
                    _ => <super::super::StartGame as ::protobuf::Message>::default_instance(),
                }
            }

            pub fn clear_start_game(&mut self) {
                self.content_type = ::std::option::Option::None;
            }

            pub fn has_start_game(&self) -> bool {
                match self.content_type {
                    ::std::option::Option::Some(replay_content::Content_type::StartGame(..)) => true,
                    _ => false,
                }
            }

            // Param is passed by value, moved
            pub fn set_start_game(&mut self, v: super::super::StartGame) {
                self.content_type = ::std::option::Option::Some(replay_content::Content_type::StartGame(v))
            }

            // Mutable pointer to the field.
            pub fn mut_start_game(&mut self) -> &mut super::super::StartGame {
                if let ::std::option::Option::Some(replay_content::Content_type::StartGame(_)) = self.content_type {
                } else {
                    self.content_type = ::std::option::Option::Some(replay_content::Content_type::StartGame(super::super::StartGame::new()));
                }
                match self.content_type {
                    ::std::option::Option::Some(replay_content::Content_type::StartGame(ref mut v)) => v,
                    _ => panic!(),
                }
            }

            // Take field
            pub fn take_start_game(&mut self) -> super::super::StartGame {
                if self.has_start_game() {
                    match self.content_type.take() {
                        ::std::option::Option::Some(replay_content::Content_type::StartGame(v)) => v,
                        _ => panic!(),
                    }
                } else {
                    super::super::StartGame::new()
                }
            }

            // .stormgate.PlayerLeftGame player_left_game = 25;

            pub fn player_left_game(&self) -> &super::super::PlayerLeftGame {
                match self.content_type {
                    ::std::option::Option::Some(replay_content::Content_type::PlayerLeftGame(ref v)) => v,
                    _ => <super::super::PlayerLeftGame as ::protobuf::Message>::default_instance(),
                }
            }

            pub fn clear_player_left_game(&mut self) {
                self.content_type = ::std::option::Option::None;
            }

            pub fn has_player_left_game(&self) -> bool {
                match self.content_type {
                    ::std::option::Option::Some(replay_content::Content_type::PlayerLeftGame(..)) => true,
                    _ => false,
                }
            }

            // Param is passed by value, moved
            pub fn set_player_left_game(&mut self, v: super::super::PlayerLeftGame) {
                self.content_type = ::std::option::Option::Some(replay_content::Content_type::PlayerLeftGame(v))
            }

            // Mutable pointer to the field.
            pub fn mut_player_left_game(&mut self) -> &mut super::super::PlayerLeftGame {
                if let ::std::option::Option::Some(replay_content::Content_type::PlayerLeftGame(_)) = self.content_type {
                } else {
                    self.content_type = ::std::option::Option::Some(replay_content::Content_type::PlayerLeftGame(super::super::PlayerLeftGame::new()));
                }
                match self.content_type {
                    ::std::option::Option::Some(replay_content::Content_type::PlayerLeftGame(ref mut v)) => v,
                    _ => panic!(),
                }
            }

            // Take field
            pub fn take_player_left_game(&mut self) -> super::super::PlayerLeftGame {
                if self.has_player_left_game() {
                    match self.content_type.take() {
                        ::std::option::Option::Some(replay_content::Content_type::PlayerLeftGame(v)) => v,
                        _ => panic!(),
                    }
                } else {
                    super::super::PlayerLeftGame::new()
                }
            }

            // .stormgate.ClientDisconnected client_disconnected = 31;

            pub fn client_disconnected(&self) -> &super::super::ClientDisconnected {
                match self.content_type {
                    ::std::option::Option::Some(replay_content::Content_type::ClientDisconnected(ref v)) => v,
                    _ => <super::super::ClientDisconnected as ::protobuf::Message>::default_instance(),
                }
            }

            pub fn clear_client_disconnected(&mut self) {
                self.content_type = ::std::option::Option::None;
            }

            pub fn has_client_disconnected(&self) -> bool {
                match self.content_type {
                    ::std::option::Option::Some(replay_content::Content_type::ClientDisconnected(..)) => true,
                    _ => false,
                }
            }

            // Param is passed by value, moved
            pub fn set_client_disconnected(&mut self, v: super::super::ClientDisconnected) {
                self.content_type = ::std::option::Option::Some(replay_content::Content_type::ClientDisconnected(v))
            }

            // Mutable pointer to the field.
            pub fn mut_client_disconnected(&mut self) -> &mut super::super::ClientDisconnected {
                if let ::std::option::Option::Some(replay_content::Content_type::ClientDisconnected(_)) = self.content_type {
                } else {
                    self.content_type = ::std::option::Option::Some(replay_content::Content_type::ClientDisconnected(super::super::ClientDisconnected::new()));
                }
                match self.content_type {
                    ::std::option::Option::Some(replay_content::Content_type::ClientDisconnected(ref mut v)) => v,
                    _ => panic!(),
                }
            }

            // Take field
            pub fn take_client_disconnected(&mut self) -> super::super::ClientDisconnected {
                if self.has_client_disconnected() {
                    match self.content_type.take() {
                        ::std::option::Option::Some(replay_content::Content_type::ClientDisconnected(v)) => v,
                        _ => panic!(),
                    }
                } else {
                    super::super::ClientDisconnected::new()
                }
            }

            // .stormgate.AssignPlayerSlot assign_player_slot = 37;

            pub fn assign_player_slot(&self) -> &super::super::AssignPlayerSlot {
                match self.content_type {
                    ::std::option::Option::Some(replay_content::Content_type::AssignPlayerSlot(ref v)) => v,
                    _ => <super::super::AssignPlayerSlot as ::protobuf::Message>::default_instance(),
                }
            }

            pub fn clear_assign_player_slot(&mut self) {
                self.content_type = ::std::option::Option::None;
            }

            pub fn has_assign_player_slot(&self) -> bool {
                match self.content_type {
                    ::std::option::Option::Some(replay_content::Content_type::AssignPlayerSlot(..)) => true,
                    _ => false,
                }
            }

            // Param is passed by value, moved
            pub fn set_assign_player_slot(&mut self, v: super::super::AssignPlayerSlot) {
                self.content_type = ::std::option::Option::Some(replay_content::Content_type::AssignPlayerSlot(v))
            }

            // Mutable pointer to the field.
            pub fn mut_assign_player_slot(&mut self) -> &mut super::super::AssignPlayerSlot {
                if let ::std::option::Option::Some(replay_content::Content_type::AssignPlayerSlot(_)) = self.content_type {
                } else {
                    self.content_type = ::std::option::Option::Some(replay_content::Content_type::AssignPlayerSlot(super::super::AssignPlayerSlot::new()));
                }
                match self.content_type {
                    ::std::option::Option::Some(replay_content::Content_type::AssignPlayerSlot(ref mut v)) => v,
                    _ => panic!(),
                }
            }

            // Take field
            pub fn take_assign_player_slot(&mut self) -> super::super::AssignPlayerSlot {
                if self.has_assign_player_slot() {
                    match self.content_type.take() {
                        ::std::option::Option::Some(replay_content::Content_type::AssignPlayerSlot(v)) => v,
                        _ => panic!(),
                    }
                } else {
                    super::super::AssignPlayerSlot::new()
                }
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(9);
                let mut oneofs = ::std::vec::Vec::with_capacity(1);
                fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::super::MapDetails>(
                    "map_details",
                    ReplayContent::has_map_details,
                    ReplayContent::map_details,
                    ReplayContent::mut_map_details,
                    ReplayContent::set_map_details,
                ));
                fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::super::ClientConnected>(
                    "client_connected",
                    ReplayContent::has_client_connected,
                    ReplayContent::client_connected,
                    ReplayContent::mut_client_connected,
                    ReplayContent::set_client_connected,
                ));
                fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::super::Player>(
                    "player",
                    ReplayContent::has_player,
                    ReplayContent::player,
                    ReplayContent::mut_player,
                    ReplayContent::set_player,
                ));
                fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::super::LobbyChangeSlot>(
                    "change_slot",
                    ReplayContent::has_change_slot,
                    ReplayContent::change_slot,
                    ReplayContent::mut_change_slot,
                    ReplayContent::set_change_slot,
                ));
                fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::super::LobbySetVariable>(
                    "set_variable",
                    ReplayContent::has_set_variable,
                    ReplayContent::set_variable,
                    ReplayContent::mut_set_variable,
                    ReplayContent::set_set_variable,
                ));
                fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::super::StartGame>(
                    "start_game",
                    ReplayContent::has_start_game,
                    ReplayContent::start_game,
                    ReplayContent::mut_start_game,
                    ReplayContent::set_start_game,
                ));
                fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::super::PlayerLeftGame>(
                    "player_left_game",
                    ReplayContent::has_player_left_game,
                    ReplayContent::player_left_game,
                    ReplayContent::mut_player_left_game,
                    ReplayContent::set_player_left_game,
                ));
                fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::super::ClientDisconnected>(
                    "client_disconnected",
                    ReplayContent::has_client_disconnected,
                    ReplayContent::client_disconnected,
                    ReplayContent::mut_client_disconnected,
                    ReplayContent::set_client_disconnected,
                ));
                fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::super::AssignPlayerSlot>(
                    "assign_player_slot",
                    ReplayContent::has_assign_player_slot,
                    ReplayContent::assign_player_slot,
                    ReplayContent::mut_assign_player_slot,
                    ReplayContent::set_assign_player_slot,
                ));
                oneofs.push(replay_content::Content_type::generated_oneof_descriptor_data());
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReplayContent>(
                    "ReplayChunk.Wrapper.ReplayContent",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for ReplayContent {
            const NAME: &'static str = "ReplayContent";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        26 => {
                            self.content_type = ::std::option::Option::Some(replay_content::Content_type::MapDetails(is.read_message()?));
                        },
                        34 => {
                            self.content_type = ::std::option::Option::Some(replay_content::Content_type::ClientConnected(is.read_message()?));
                        },
                        98 => {
                            self.content_type = ::std::option::Option::Some(replay_content::Content_type::Player(is.read_message()?));
                        },
                        106 => {
                            self.content_type = ::std::option::Option::Some(replay_content::Content_type::ChangeSlot(is.read_message()?));
                        },
                        122 => {
                            self.content_type = ::std::option::Option::Some(replay_content::Content_type::SetVariable(is.read_message()?));
                        },
                        146 => {
                            self.content_type = ::std::option::Option::Some(replay_content::Content_type::StartGame(is.read_message()?));
                        },
                        202 => {
                            self.content_type = ::std::option::Option::Some(replay_content::Content_type::PlayerLeftGame(is.read_message()?));
                        },
                        250 => {
                            self.content_type = ::std::option::Option::Some(replay_content::Content_type::ClientDisconnected(is.read_message()?));
                        },
                        298 => {
                            self.content_type = ::std::option::Option::Some(replay_content::Content_type::AssignPlayerSlot(is.read_message()?));
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let ::std::option::Option::Some(ref v) = self.content_type {
                    match v {
                        &replay_content::Content_type::MapDetails(ref v) => {
                            let len = v.compute_size();
                            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                        },
                        &replay_content::Content_type::ClientConnected(ref v) => {
                            let len = v.compute_size();
                            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                        },
                        &replay_content::Content_type::Player(ref v) => {
                            let len = v.compute_size();
                            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                        },
                        &replay_content::Content_type::ChangeSlot(ref v) => {
                            let len = v.compute_size();
                            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                        },
                        &replay_content::Content_type::SetVariable(ref v) => {
                            let len = v.compute_size();
                            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                        },
                        &replay_content::Content_type::StartGame(ref v) => {
                            let len = v.compute_size();
                            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                        },
                        &replay_content::Content_type::PlayerLeftGame(ref v) => {
                            let len = v.compute_size();
                            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                        },
                        &replay_content::Content_type::ClientDisconnected(ref v) => {
                            let len = v.compute_size();
                            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                        },
                        &replay_content::Content_type::AssignPlayerSlot(ref v) => {
                            let len = v.compute_size();
                            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                        },
                    };
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let ::std::option::Option::Some(ref v) = self.content_type {
                    match v {
                        &replay_content::Content_type::MapDetails(ref v) => {
                            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                        },
                        &replay_content::Content_type::ClientConnected(ref v) => {
                            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                        },
                        &replay_content::Content_type::Player(ref v) => {
                            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
                        },
                        &replay_content::Content_type::ChangeSlot(ref v) => {
                            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
                        },
                        &replay_content::Content_type::SetVariable(ref v) => {
                            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
                        },
                        &replay_content::Content_type::StartGame(ref v) => {
                            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
                        },
                        &replay_content::Content_type::PlayerLeftGame(ref v) => {
                            ::protobuf::rt::write_message_field_with_cached_size(25, v, os)?;
                        },
                        &replay_content::Content_type::ClientDisconnected(ref v) => {
                            ::protobuf::rt::write_message_field_with_cached_size(31, v, os)?;
                        },
                        &replay_content::Content_type::AssignPlayerSlot(ref v) => {
                            ::protobuf::rt::write_message_field_with_cached_size(37, v, os)?;
                        },
                    };
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> ReplayContent {
                ReplayContent::new()
            }

            fn clear(&mut self) {
                self.content_type = ::std::option::Option::None;
                self.content_type = ::std::option::Option::None;
                self.content_type = ::std::option::Option::None;
                self.content_type = ::std::option::Option::None;
                self.content_type = ::std::option::Option::None;
                self.content_type = ::std::option::Option::None;
                self.content_type = ::std::option::Option::None;
                self.content_type = ::std::option::Option::None;
                self.content_type = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static ReplayContent {
                static instance: ReplayContent = ReplayContent {
                    content_type: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for ReplayContent {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("ReplayChunk.Wrapper.ReplayContent").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for ReplayContent {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for ReplayContent {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        /// Nested message and enums of message `ReplayContent`
        pub mod replay_content {

            #[derive(Clone,PartialEq,Debug)]
            #[non_exhaustive]
            // @@protoc_insertion_point(oneof:stormgate.ReplayChunk.Wrapper.ReplayContent.content_type)
            pub enum Content_type {
                // @@protoc_insertion_point(oneof_field:stormgate.ReplayChunk.Wrapper.ReplayContent.map_details)
                MapDetails(super::super::super::MapDetails),
                // @@protoc_insertion_point(oneof_field:stormgate.ReplayChunk.Wrapper.ReplayContent.client_connected)
                ClientConnected(super::super::super::ClientConnected),
                // @@protoc_insertion_point(oneof_field:stormgate.ReplayChunk.Wrapper.ReplayContent.player)
                Player(super::super::super::Player),
                // @@protoc_insertion_point(oneof_field:stormgate.ReplayChunk.Wrapper.ReplayContent.change_slot)
                ChangeSlot(super::super::super::LobbyChangeSlot),
                // @@protoc_insertion_point(oneof_field:stormgate.ReplayChunk.Wrapper.ReplayContent.set_variable)
                SetVariable(super::super::super::LobbySetVariable),
                // @@protoc_insertion_point(oneof_field:stormgate.ReplayChunk.Wrapper.ReplayContent.start_game)
                StartGame(super::super::super::StartGame),
                // @@protoc_insertion_point(oneof_field:stormgate.ReplayChunk.Wrapper.ReplayContent.player_left_game)
                PlayerLeftGame(super::super::super::PlayerLeftGame),
                // @@protoc_insertion_point(oneof_field:stormgate.ReplayChunk.Wrapper.ReplayContent.client_disconnected)
                ClientDisconnected(super::super::super::ClientDisconnected),
                // @@protoc_insertion_point(oneof_field:stormgate.ReplayChunk.Wrapper.ReplayContent.assign_player_slot)
                AssignPlayerSlot(super::super::super::AssignPlayerSlot),
            }

            impl ::protobuf::Oneof for Content_type {
            }

            impl ::protobuf::OneofFull for Content_type {
                fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                    static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                    descriptor.get(|| <super::ReplayContent as ::protobuf::MessageFull>::descriptor().oneof_by_name("content_type").unwrap()).clone()
                }
            }

            impl Content_type {
                pub(in super::super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                    ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Content_type>("content_type")
                }
            }
        }
    }
}

///  3 - Map identifier + RNG seed
// @@protoc_insertion_point(message:stormgate.MapDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MapDetails {
    // message fields
    // @@protoc_insertion_point(field:stormgate.MapDetails.map_folder)
    pub map_folder: ::std::string::String,
    // @@protoc_insertion_point(field:stormgate.MapDetails.map_name)
    pub map_name: ::std::string::String,
    // @@protoc_insertion_point(field:stormgate.MapDetails.map_seed)
    pub map_seed: i32,
    // @@protoc_insertion_point(field:stormgate.MapDetails.match_type)
    pub match_type: ::protobuf::EnumOrUnknown<MatchType>,
    // special fields
    // @@protoc_insertion_point(special_field:stormgate.MapDetails.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MapDetails {
    fn default() -> &'a MapDetails {
        <MapDetails as ::protobuf::Message>::default_instance()
    }
}

impl MapDetails {
    pub fn new() -> MapDetails {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "map_folder",
            |m: &MapDetails| { &m.map_folder },
            |m: &mut MapDetails| { &mut m.map_folder },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "map_name",
            |m: &MapDetails| { &m.map_name },
            |m: &mut MapDetails| { &mut m.map_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "map_seed",
            |m: &MapDetails| { &m.map_seed },
            |m: &mut MapDetails| { &mut m.map_seed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "match_type",
            |m: &MapDetails| { &m.match_type },
            |m: &mut MapDetails| { &mut m.match_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MapDetails>(
            "MapDetails",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MapDetails {
    const NAME: &'static str = "MapDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.map_folder = is.read_string()?;
                },
                18 => {
                    self.map_name = is.read_string()?;
                },
                24 => {
                    self.map_seed = is.read_int32()?;
                },
                56 => {
                    self.match_type = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.map_folder.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.map_folder);
        }
        if !self.map_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.map_name);
        }
        if self.map_seed != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.map_seed);
        }
        if self.match_type != ::protobuf::EnumOrUnknown::new(MatchType::UnknownMatchType) {
            my_size += ::protobuf::rt::int32_size(7, self.match_type.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.map_folder.is_empty() {
            os.write_string(1, &self.map_folder)?;
        }
        if !self.map_name.is_empty() {
            os.write_string(2, &self.map_name)?;
        }
        if self.map_seed != 0 {
            os.write_int32(3, self.map_seed)?;
        }
        if self.match_type != ::protobuf::EnumOrUnknown::new(MatchType::UnknownMatchType) {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&self.match_type))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MapDetails {
        MapDetails::new()
    }

    fn clear(&mut self) {
        self.map_folder.clear();
        self.map_name.clear();
        self.map_seed = 0;
        self.match_type = ::protobuf::EnumOrUnknown::new(MatchType::UnknownMatchType);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MapDetails {
        static instance: MapDetails = MapDetails {
            map_folder: ::std::string::String::new(),
            map_name: ::std::string::String::new(),
            map_seed: 0,
            match_type: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MapDetails {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MapDetails").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MapDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MapDetails {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  4 - sent by server after each player connects?
///  in new co-op replay it's the only way to link a player to their client_id.
// @@protoc_insertion_point(message:stormgate.ClientConnected)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ClientConnected {
    // message fields
    // @@protoc_insertion_point(field:stormgate.ClientConnected.client_id)
    pub client_id: i32,
    // @@protoc_insertion_point(field:stormgate.ClientConnected.uuid)
    pub uuid: ::protobuf::MessageField<UUID>,
    // special fields
    // @@protoc_insertion_point(special_field:stormgate.ClientConnected.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClientConnected {
    fn default() -> &'a ClientConnected {
        <ClientConnected as ::protobuf::Message>::default_instance()
    }
}

impl ClientConnected {
    pub fn new() -> ClientConnected {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "client_id",
            |m: &ClientConnected| { &m.client_id },
            |m: &mut ClientConnected| { &mut m.client_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, UUID>(
            "uuid",
            |m: &ClientConnected| { &m.uuid },
            |m: &mut ClientConnected| { &mut m.uuid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ClientConnected>(
            "ClientConnected",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ClientConnected {
    const NAME: &'static str = "ClientConnected";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.client_id = is.read_int32()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.uuid)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.client_id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.client_id);
        }
        if let Some(v) = self.uuid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.client_id != 0 {
            os.write_int32(1, self.client_id)?;
        }
        if let Some(v) = self.uuid.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClientConnected {
        ClientConnected::new()
    }

    fn clear(&mut self) {
        self.client_id = 0;
        self.uuid.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClientConnected {
        static instance: ClientConnected = ClientConnected {
            client_id: 0,
            uuid: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ClientConnected {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClientConnected").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClientConnected {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientConnected {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  12 - Sent by a player when they join a game
// @@protoc_insertion_point(message:stormgate.Player)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Player {
    // message fields
    // @@protoc_insertion_point(field:stormgate.Player.uuid)
    pub uuid: ::protobuf::MessageField<UUID>,
    // @@protoc_insertion_point(field:stormgate.Player.name)
    pub name: ::protobuf::MessageField<player::PlayerName>,
    // special fields
    // @@protoc_insertion_point(special_field:stormgate.Player.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Player {
    fn default() -> &'a Player {
        <Player as ::protobuf::Message>::default_instance()
    }
}

impl Player {
    pub fn new() -> Player {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, UUID>(
            "uuid",
            |m: &Player| { &m.uuid },
            |m: &mut Player| { &mut m.uuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, player::PlayerName>(
            "name",
            |m: &Player| { &m.name },
            |m: &mut Player| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Player>(
            "Player",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Player {
    const NAME: &'static str = "Player";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.uuid)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.name)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.uuid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.name.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.uuid.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.name.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Player {
        Player::new()
    }

    fn clear(&mut self) {
        self.uuid.clear();
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Player {
        static instance: Player = Player {
            uuid: ::protobuf::MessageField::none(),
            name: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Player {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Player").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Player {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Player {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Player`
pub mod player {
    // @@protoc_insertion_point(message:stormgate.Player.PlayerName)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PlayerName {
        // message fields
        // @@protoc_insertion_point(field:stormgate.Player.PlayerName.nickname)
        pub nickname: ::std::string::String,
        // @@protoc_insertion_point(field:stormgate.Player.PlayerName.discriminator)
        pub discriminator: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:stormgate.Player.PlayerName.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PlayerName {
        fn default() -> &'a PlayerName {
            <PlayerName as ::protobuf::Message>::default_instance()
        }
    }

    impl PlayerName {
        pub fn new() -> PlayerName {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "nickname",
                |m: &PlayerName| { &m.nickname },
                |m: &mut PlayerName| { &mut m.nickname },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "discriminator",
                |m: &PlayerName| { &m.discriminator },
                |m: &mut PlayerName| { &mut m.discriminator },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlayerName>(
                "Player.PlayerName",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PlayerName {
        const NAME: &'static str = "PlayerName";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.nickname = is.read_string()?;
                    },
                    18 => {
                        self.discriminator = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.nickname.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.nickname);
            }
            if !self.discriminator.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.discriminator);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.nickname.is_empty() {
                os.write_string(1, &self.nickname)?;
            }
            if !self.discriminator.is_empty() {
                os.write_string(2, &self.discriminator)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PlayerName {
            PlayerName::new()
        }

        fn clear(&mut self) {
            self.nickname.clear();
            self.discriminator.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PlayerName {
            static instance: PlayerName = PlayerName {
                nickname: ::std::string::String::new(),
                discriminator: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PlayerName {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Player.PlayerName").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PlayerName {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PlayerName {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

///  13 - Sent when player changes slot (leave/enter), note that SlotChoice
///  contains either a request for a specific slot, or what I assume is a "next
///  slot available", slot 255 is observer
// @@protoc_insertion_point(message:stormgate.LobbyChangeSlot)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LobbyChangeSlot {
    // message fields
    // @@protoc_insertion_point(field:stormgate.LobbyChangeSlot.choice)
    pub choice: ::protobuf::MessageField<lobby_change_slot::SlotChoice>,
    // special fields
    // @@protoc_insertion_point(special_field:stormgate.LobbyChangeSlot.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LobbyChangeSlot {
    fn default() -> &'a LobbyChangeSlot {
        <LobbyChangeSlot as ::protobuf::Message>::default_instance()
    }
}

impl LobbyChangeSlot {
    pub fn new() -> LobbyChangeSlot {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, lobby_change_slot::SlotChoice>(
            "choice",
            |m: &LobbyChangeSlot| { &m.choice },
            |m: &mut LobbyChangeSlot| { &mut m.choice },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LobbyChangeSlot>(
            "LobbyChangeSlot",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LobbyChangeSlot {
    const NAME: &'static str = "LobbyChangeSlot";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.choice)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.choice.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.choice.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LobbyChangeSlot {
        LobbyChangeSlot::new()
    }

    fn clear(&mut self) {
        self.choice.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LobbyChangeSlot {
        static instance: LobbyChangeSlot = LobbyChangeSlot {
            choice: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LobbyChangeSlot {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LobbyChangeSlot").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LobbyChangeSlot {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LobbyChangeSlot {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `LobbyChangeSlot`
pub mod lobby_change_slot {
    // @@protoc_insertion_point(message:stormgate.LobbyChangeSlot.SlotChoice)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SlotChoice {
        // message oneof groups
        pub choice_type: ::std::option::Option<slot_choice::Choice_type>,
        // special fields
        // @@protoc_insertion_point(special_field:stormgate.LobbyChangeSlot.SlotChoice.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SlotChoice {
        fn default() -> &'a SlotChoice {
            <SlotChoice as ::protobuf::Message>::default_instance()
        }
    }

    impl SlotChoice {
        pub fn new() -> SlotChoice {
            ::std::default::Default::default()
        }

        // .stormgate.LobbyChangeSlot.SlotChoice.SpecificSlot specific_slot = 2;

        pub fn specific_slot(&self) -> &slot_choice::SpecificSlot {
            match self.choice_type {
                ::std::option::Option::Some(slot_choice::Choice_type::SpecificSlot(ref v)) => v,
                _ => <slot_choice::SpecificSlot as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_specific_slot(&mut self) {
            self.choice_type = ::std::option::Option::None;
        }

        pub fn has_specific_slot(&self) -> bool {
            match self.choice_type {
                ::std::option::Option::Some(slot_choice::Choice_type::SpecificSlot(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_specific_slot(&mut self, v: slot_choice::SpecificSlot) {
            self.choice_type = ::std::option::Option::Some(slot_choice::Choice_type::SpecificSlot(v))
        }

        // Mutable pointer to the field.
        pub fn mut_specific_slot(&mut self) -> &mut slot_choice::SpecificSlot {
            if let ::std::option::Option::Some(slot_choice::Choice_type::SpecificSlot(_)) = self.choice_type {
            } else {
                self.choice_type = ::std::option::Option::Some(slot_choice::Choice_type::SpecificSlot(slot_choice::SpecificSlot::new()));
            }
            match self.choice_type {
                ::std::option::Option::Some(slot_choice::Choice_type::SpecificSlot(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_specific_slot(&mut self) -> slot_choice::SpecificSlot {
            if self.has_specific_slot() {
                match self.choice_type.take() {
                    ::std::option::Option::Some(slot_choice::Choice_type::SpecificSlot(v)) => v,
                    _ => panic!(),
                }
            } else {
                slot_choice::SpecificSlot::new()
            }
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(1);
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, slot_choice::SpecificSlot>(
                "specific_slot",
                SlotChoice::has_specific_slot,
                SlotChoice::specific_slot,
                SlotChoice::mut_specific_slot,
                SlotChoice::set_specific_slot,
            ));
            oneofs.push(slot_choice::Choice_type::generated_oneof_descriptor_data());
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SlotChoice>(
                "LobbyChangeSlot.SlotChoice",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SlotChoice {
        const NAME: &'static str = "SlotChoice";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    18 => {
                        self.choice_type = ::std::option::Option::Some(slot_choice::Choice_type::SpecificSlot(is.read_message()?));
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let ::std::option::Option::Some(ref v) = self.choice_type {
                match v {
                    &slot_choice::Choice_type::SpecificSlot(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                };
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let ::std::option::Option::Some(ref v) = self.choice_type {
                match v {
                    &slot_choice::Choice_type::SpecificSlot(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                    },
                };
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SlotChoice {
            SlotChoice::new()
        }

        fn clear(&mut self) {
            self.choice_type = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SlotChoice {
            static instance: SlotChoice = SlotChoice {
                choice_type: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SlotChoice {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("LobbyChangeSlot.SlotChoice").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SlotChoice {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SlotChoice {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `SlotChoice`
    pub mod slot_choice {

        #[derive(Clone,PartialEq,Debug)]
        #[non_exhaustive]
        // @@protoc_insertion_point(oneof:stormgate.LobbyChangeSlot.SlotChoice.choice_type)
        pub enum Choice_type {
            // @@protoc_insertion_point(oneof_field:stormgate.LobbyChangeSlot.SlotChoice.specific_slot)
            SpecificSlot(SpecificSlot),
        }

        impl ::protobuf::Oneof for Choice_type {
        }

        impl ::protobuf::OneofFull for Choice_type {
            fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| <super::SlotChoice as ::protobuf::MessageFull>::descriptor().oneof_by_name("choice_type").unwrap()).clone()
            }
        }

        impl Choice_type {
            pub(in super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Choice_type>("choice_type")
            }
        }
        // @@protoc_insertion_point(message:stormgate.LobbyChangeSlot.SlotChoice.SpecificSlot)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct SpecificSlot {
            // message fields
            // @@protoc_insertion_point(field:stormgate.LobbyChangeSlot.SlotChoice.SpecificSlot.slot)
            pub slot: i32,
            // special fields
            // @@protoc_insertion_point(special_field:stormgate.LobbyChangeSlot.SlotChoice.SpecificSlot.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a SpecificSlot {
            fn default() -> &'a SpecificSlot {
                <SpecificSlot as ::protobuf::Message>::default_instance()
            }
        }

        impl SpecificSlot {
            pub fn new() -> SpecificSlot {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(1);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "slot",
                    |m: &SpecificSlot| { &m.slot },
                    |m: &mut SpecificSlot| { &mut m.slot },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SpecificSlot>(
                    "LobbyChangeSlot.SlotChoice.SpecificSlot",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for SpecificSlot {
            const NAME: &'static str = "SpecificSlot";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.slot = is.read_int32()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.slot != 0 {
                    my_size += ::protobuf::rt::int32_size(1, self.slot);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.slot != 0 {
                    os.write_int32(1, self.slot)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> SpecificSlot {
                SpecificSlot::new()
            }

            fn clear(&mut self) {
                self.slot = 0;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static SpecificSlot {
                static instance: SpecificSlot = SpecificSlot {
                    slot: 0,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for SpecificSlot {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("LobbyChangeSlot.SlotChoice.SpecificSlot").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for SpecificSlot {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for SpecificSlot {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

///  15 - Sent when a player slot has a variable changed
///  Var 374945738: Type, 0 = Closed, 1 = Human, 2 = AI
///  Var 2952722564: Faction, 0 = Vanguard, 1 = Infernals
///  Var 655515685: AIType, 0 = Peaceful, 1 = Junior, 2 = Senior
// @@protoc_insertion_point(message:stormgate.LobbySetVariable)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LobbySetVariable {
    // message fields
    // @@protoc_insertion_point(field:stormgate.LobbySetVariable.slot)
    pub slot: i32,
    // @@protoc_insertion_point(field:stormgate.LobbySetVariable.variable_id)
    pub variable_id: u32,
    // @@protoc_insertion_point(field:stormgate.LobbySetVariable.value)
    pub value: u32,
    // special fields
    // @@protoc_insertion_point(special_field:stormgate.LobbySetVariable.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LobbySetVariable {
    fn default() -> &'a LobbySetVariable {
        <LobbySetVariable as ::protobuf::Message>::default_instance()
    }
}

impl LobbySetVariable {
    pub fn new() -> LobbySetVariable {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "slot",
            |m: &LobbySetVariable| { &m.slot },
            |m: &mut LobbySetVariable| { &mut m.slot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "variable_id",
            |m: &LobbySetVariable| { &m.variable_id },
            |m: &mut LobbySetVariable| { &mut m.variable_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &LobbySetVariable| { &m.value },
            |m: &mut LobbySetVariable| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LobbySetVariable>(
            "LobbySetVariable",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LobbySetVariable {
    const NAME: &'static str = "LobbySetVariable";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                24 => {
                    self.slot = is.read_int32()?;
                },
                32 => {
                    self.variable_id = is.read_uint32()?;
                },
                40 => {
                    self.value = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.slot != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.slot);
        }
        if self.variable_id != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.variable_id);
        }
        if self.value != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.slot != 0 {
            os.write_int32(3, self.slot)?;
        }
        if self.variable_id != 0 {
            os.write_uint32(4, self.variable_id)?;
        }
        if self.value != 0 {
            os.write_uint32(5, self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LobbySetVariable {
        LobbySetVariable::new()
    }

    fn clear(&mut self) {
        self.slot = 0;
        self.variable_id = 0;
        self.value = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LobbySetVariable {
        static instance: LobbySetVariable = LobbySetVariable {
            slot: 0,
            variable_id: 0,
            value: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LobbySetVariable {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LobbySetVariable").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LobbySetVariable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LobbySetVariable {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  18 - "Start Game" Sent by players after second ReadyUp, that probably indicates player finished loading into the map
// @@protoc_insertion_point(message:stormgate.StartGame)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StartGame {
    // special fields
    // @@protoc_insertion_point(special_field:stormgate.StartGame.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StartGame {
    fn default() -> &'a StartGame {
        <StartGame as ::protobuf::Message>::default_instance()
    }
}

impl StartGame {
    pub fn new() -> StartGame {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StartGame>(
            "StartGame",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StartGame {
    const NAME: &'static str = "StartGame";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StartGame {
        StartGame::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StartGame {
        static instance: StartGame = StartGame {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StartGame {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StartGame").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StartGame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StartGame {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  25 - When a player exits the game/disconnects
// @@protoc_insertion_point(message:stormgate.PlayerLeftGame)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PlayerLeftGame {
    // message fields
    // @@protoc_insertion_point(field:stormgate.PlayerLeftGame.player_uuid)
    pub player_uuid: ::protobuf::MessageField<UUID>,
    // @@protoc_insertion_point(field:stormgate.PlayerLeftGame.reason)
    pub reason: ::protobuf::EnumOrUnknown<LeaveReason>,
    // special fields
    // @@protoc_insertion_point(special_field:stormgate.PlayerLeftGame.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PlayerLeftGame {
    fn default() -> &'a PlayerLeftGame {
        <PlayerLeftGame as ::protobuf::Message>::default_instance()
    }
}

impl PlayerLeftGame {
    pub fn new() -> PlayerLeftGame {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, UUID>(
            "player_uuid",
            |m: &PlayerLeftGame| { &m.player_uuid },
            |m: &mut PlayerLeftGame| { &mut m.player_uuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "reason",
            |m: &PlayerLeftGame| { &m.reason },
            |m: &mut PlayerLeftGame| { &mut m.reason },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlayerLeftGame>(
            "PlayerLeftGame",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PlayerLeftGame {
    const NAME: &'static str = "PlayerLeftGame";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.player_uuid)?;
                },
                16 => {
                    self.reason = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_uuid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.reason != ::protobuf::EnumOrUnknown::new(LeaveReason::UnknownReason) {
            my_size += ::protobuf::rt::int32_size(2, self.reason.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_uuid.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.reason != ::protobuf::EnumOrUnknown::new(LeaveReason::UnknownReason) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.reason))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PlayerLeftGame {
        PlayerLeftGame::new()
    }

    fn clear(&mut self) {
        self.player_uuid.clear();
        self.reason = ::protobuf::EnumOrUnknown::new(LeaveReason::UnknownReason);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PlayerLeftGame {
        static instance: PlayerLeftGame = PlayerLeftGame {
            player_uuid: ::protobuf::MessageField::none(),
            reason: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PlayerLeftGame {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PlayerLeftGame").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PlayerLeftGame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayerLeftGame {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  31 - sent by the server after a client disconnects
// @@protoc_insertion_point(message:stormgate.ClientDisconnected)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ClientDisconnected {
    // message fields
    // @@protoc_insertion_point(field:stormgate.ClientDisconnected.client_id)
    pub client_id: i32,
    // @@protoc_insertion_point(field:stormgate.ClientDisconnected.reason)
    pub reason: ::protobuf::EnumOrUnknown<LeaveReason>,
    // @@protoc_insertion_point(field:stormgate.ClientDisconnected.player_uuid)
    pub player_uuid: ::protobuf::MessageField<UUID>,
    // special fields
    // @@protoc_insertion_point(special_field:stormgate.ClientDisconnected.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClientDisconnected {
    fn default() -> &'a ClientDisconnected {
        <ClientDisconnected as ::protobuf::Message>::default_instance()
    }
}

impl ClientDisconnected {
    pub fn new() -> ClientDisconnected {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "client_id",
            |m: &ClientDisconnected| { &m.client_id },
            |m: &mut ClientDisconnected| { &mut m.client_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "reason",
            |m: &ClientDisconnected| { &m.reason },
            |m: &mut ClientDisconnected| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, UUID>(
            "player_uuid",
            |m: &ClientDisconnected| { &m.player_uuid },
            |m: &mut ClientDisconnected| { &mut m.player_uuid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ClientDisconnected>(
            "ClientDisconnected",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ClientDisconnected {
    const NAME: &'static str = "ClientDisconnected";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.client_id = is.read_int32()?;
                },
                16 => {
                    self.reason = is.read_enum_or_unknown()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.player_uuid)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.client_id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.client_id);
        }
        if self.reason != ::protobuf::EnumOrUnknown::new(LeaveReason::UnknownReason) {
            my_size += ::protobuf::rt::int32_size(2, self.reason.value());
        }
        if let Some(v) = self.player_uuid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.client_id != 0 {
            os.write_int32(1, self.client_id)?;
        }
        if self.reason != ::protobuf::EnumOrUnknown::new(LeaveReason::UnknownReason) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.reason))?;
        }
        if let Some(v) = self.player_uuid.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClientDisconnected {
        ClientDisconnected::new()
    }

    fn clear(&mut self) {
        self.client_id = 0;
        self.reason = ::protobuf::EnumOrUnknown::new(LeaveReason::UnknownReason);
        self.player_uuid.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClientDisconnected {
        static instance: ClientDisconnected = ClientDisconnected {
            client_id: 0,
            reason: ::protobuf::EnumOrUnknown::from_i32(0),
            player_uuid: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ClientDisconnected {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClientDisconnected").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClientDisconnected {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientDisconnected {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  37 - AssignPlayer (done by server as pl=64)
///  Appears only in ladder games?
// @@protoc_insertion_point(message:stormgate.AssignPlayerSlot)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AssignPlayerSlot {
    // message fields
    // @@protoc_insertion_point(field:stormgate.AssignPlayerSlot.uuid)
    pub uuid: ::protobuf::MessageField<UUID>,
    // @@protoc_insertion_point(field:stormgate.AssignPlayerSlot.slot)
    pub slot: i32,
    // @@protoc_insertion_point(field:stormgate.AssignPlayerSlot.nickname)
    pub nickname: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:stormgate.AssignPlayerSlot.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AssignPlayerSlot {
    fn default() -> &'a AssignPlayerSlot {
        <AssignPlayerSlot as ::protobuf::Message>::default_instance()
    }
}

impl AssignPlayerSlot {
    pub fn new() -> AssignPlayerSlot {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, UUID>(
            "uuid",
            |m: &AssignPlayerSlot| { &m.uuid },
            |m: &mut AssignPlayerSlot| { &mut m.uuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "slot",
            |m: &AssignPlayerSlot| { &m.slot },
            |m: &mut AssignPlayerSlot| { &mut m.slot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "nickname",
            |m: &AssignPlayerSlot| { &m.nickname },
            |m: &mut AssignPlayerSlot| { &mut m.nickname },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AssignPlayerSlot>(
            "AssignPlayerSlot",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AssignPlayerSlot {
    const NAME: &'static str = "AssignPlayerSlot";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.uuid)?;
                },
                16 => {
                    self.slot = is.read_int32()?;
                },
                26 => {
                    self.nickname = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.uuid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.slot != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.slot);
        }
        if !self.nickname.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.nickname);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.uuid.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.slot != 0 {
            os.write_int32(2, self.slot)?;
        }
        if !self.nickname.is_empty() {
            os.write_string(3, &self.nickname)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AssignPlayerSlot {
        AssignPlayerSlot::new()
    }

    fn clear(&mut self) {
        self.uuid.clear();
        self.slot = 0;
        self.nickname.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AssignPlayerSlot {
        static instance: AssignPlayerSlot = AssignPlayerSlot {
            uuid: ::protobuf::MessageField::none(),
            slot: 0,
            nickname: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AssignPlayerSlot {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AssignPlayerSlot").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AssignPlayerSlot {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AssignPlayerSlot {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:stormgate.UUID)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UUID {
    // message fields
    // @@protoc_insertion_point(field:stormgate.UUID.part1)
    pub part1: u64,
    // @@protoc_insertion_point(field:stormgate.UUID.part2)
    pub part2: u64,
    // special fields
    // @@protoc_insertion_point(special_field:stormgate.UUID.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UUID {
    fn default() -> &'a UUID {
        <UUID as ::protobuf::Message>::default_instance()
    }
}

impl UUID {
    pub fn new() -> UUID {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "part1",
            |m: &UUID| { &m.part1 },
            |m: &mut UUID| { &mut m.part1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "part2",
            |m: &UUID| { &m.part2 },
            |m: &mut UUID| { &mut m.part2 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UUID>(
            "UUID",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UUID {
    const NAME: &'static str = "UUID";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.part1 = is.read_uint64()?;
                },
                16 => {
                    self.part2 = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.part1 != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.part1);
        }
        if self.part2 != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.part2);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.part1 != 0 {
            os.write_uint64(1, self.part1)?;
        }
        if self.part2 != 0 {
            os.write_uint64(2, self.part2)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UUID {
        UUID::new()
    }

    fn clear(&mut self) {
        self.part1 = 0;
        self.part2 = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UUID {
        static instance: UUID = UUID {
            part1: 0,
            part2: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UUID {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UUID").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UUID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UUID {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:stormgate.MatchType)
pub enum MatchType {
    // @@protoc_insertion_point(enum_value:stormgate.MatchType.UnknownMatchType)
    UnknownMatchType = 0,
    // @@protoc_insertion_point(enum_value:stormgate.MatchType.Custom)
    Custom = 1,
    // @@protoc_insertion_point(enum_value:stormgate.MatchType.Ranked1v1)
    Ranked1v1 = 2,
    // @@protoc_insertion_point(enum_value:stormgate.MatchType.Coop3vE)
    Coop3vE = 3,
}

impl ::protobuf::Enum for MatchType {
    const NAME: &'static str = "MatchType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MatchType> {
        match value {
            0 => ::std::option::Option::Some(MatchType::UnknownMatchType),
            1 => ::std::option::Option::Some(MatchType::Custom),
            2 => ::std::option::Option::Some(MatchType::Ranked1v1),
            3 => ::std::option::Option::Some(MatchType::Coop3vE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<MatchType> {
        match str {
            "UnknownMatchType" => ::std::option::Option::Some(MatchType::UnknownMatchType),
            "Custom" => ::std::option::Option::Some(MatchType::Custom),
            "Ranked1v1" => ::std::option::Option::Some(MatchType::Ranked1v1),
            "Coop3vE" => ::std::option::Option::Some(MatchType::Coop3vE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [MatchType] = &[
        MatchType::UnknownMatchType,
        MatchType::Custom,
        MatchType::Ranked1v1,
        MatchType::Coop3vE,
    ];
}

impl ::protobuf::EnumFull for MatchType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("MatchType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for MatchType {
    fn default() -> Self {
        MatchType::UnknownMatchType
    }
}

impl MatchType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MatchType>("MatchType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:stormgate.LeaveReason)
pub enum LeaveReason {
    // @@protoc_insertion_point(enum_value:stormgate.LeaveReason.UnknownReason)
    UnknownReason = 0,
    // @@protoc_insertion_point(enum_value:stormgate.LeaveReason.Surrender)
    Surrender = 1,
    // @@protoc_insertion_point(enum_value:stormgate.LeaveReason.Leave)
    Leave = 2,
    // @@protoc_insertion_point(enum_value:stormgate.LeaveReason.Disconnect)
    Disconnect = 3,
}

impl ::protobuf::Enum for LeaveReason {
    const NAME: &'static str = "LeaveReason";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LeaveReason> {
        match value {
            0 => ::std::option::Option::Some(LeaveReason::UnknownReason),
            1 => ::std::option::Option::Some(LeaveReason::Surrender),
            2 => ::std::option::Option::Some(LeaveReason::Leave),
            3 => ::std::option::Option::Some(LeaveReason::Disconnect),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<LeaveReason> {
        match str {
            "UnknownReason" => ::std::option::Option::Some(LeaveReason::UnknownReason),
            "Surrender" => ::std::option::Option::Some(LeaveReason::Surrender),
            "Leave" => ::std::option::Option::Some(LeaveReason::Leave),
            "Disconnect" => ::std::option::Option::Some(LeaveReason::Disconnect),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [LeaveReason] = &[
        LeaveReason::UnknownReason,
        LeaveReason::Surrender,
        LeaveReason::Leave,
        LeaveReason::Disconnect,
    ];
}

impl ::protobuf::EnumFull for LeaveReason {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("LeaveReason").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for LeaveReason {
    fn default() -> Self {
        LeaveReason::UnknownReason
    }
}

impl LeaveReason {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<LeaveReason>("LeaveReason")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0fstormgate.proto\x12\tstormgate\"\xc2\x06\n\x0bReplayChunk\x12\x1c\
    \n\ttimestamp\x18\x01\x20\x01(\x05R\ttimestamp\x12\x1b\n\tclient_id\x18\
    \x02\x20\x01(\x05R\x08clientId\x124\n\x05inner\x18\x03\x20\x01(\x0b2\x1e\
    .stormgate.ReplayChunk.WrapperR\x05inner\x1a\xc1\x05\n\x07Wrapper\x12F\n\
    \x07content\x18\x01\x20\x01(\x0b2,.stormgate.ReplayChunk.Wrapper.ReplayC\
    ontentR\x07content\x1a\xed\x04\n\rReplayContent\x128\n\x0bmap_details\
    \x18\x03\x20\x01(\x0b2\x15.stormgate.MapDetailsH\0R\nmapDetails\x12G\n\
    \x10client_connected\x18\x04\x20\x01(\x0b2\x1a.stormgate.ClientConnected\
    H\0R\x0fclientConnected\x12+\n\x06player\x18\x0c\x20\x01(\x0b2\x11.storm\
    gate.PlayerH\0R\x06player\x12=\n\x0bchange_slot\x18\r\x20\x01(\x0b2\x1a.\
    stormgate.LobbyChangeSlotH\0R\nchangeSlot\x12@\n\x0cset_variable\x18\x0f\
    \x20\x01(\x0b2\x1b.stormgate.LobbySetVariableH\0R\x0bsetVariable\x125\n\
    \nstart_game\x18\x12\x20\x01(\x0b2\x14.stormgate.StartGameH\0R\tstartGam\
    e\x12E\n\x10player_left_game\x18\x19\x20\x01(\x0b2\x19.stormgate.PlayerL\
    eftGameH\0R\x0eplayerLeftGame\x12P\n\x13client_disconnected\x18\x1f\x20\
    \x01(\x0b2\x1d.stormgate.ClientDisconnectedH\0R\x12clientDisconnected\
    \x12K\n\x12assign_player_slot\x18%\x20\x01(\x0b2\x1b.stormgate.AssignPla\
    yerSlotH\0R\x10assignPlayerSlotB\x0e\n\x0ccontent_type\"\x96\x01\n\nMapD\
    etails\x12\x1d\n\nmap_folder\x18\x01\x20\x01(\tR\tmapFolder\x12\x19\n\
    \x08map_name\x18\x02\x20\x01(\tR\x07mapName\x12\x19\n\x08map_seed\x18\
    \x03\x20\x01(\x05R\x07mapSeed\x123\n\nmatch_type\x18\x07\x20\x01(\x0e2\
    \x14.stormgate.MatchTypeR\tmatchType\"S\n\x0fClientConnected\x12\x1b\n\t\
    client_id\x18\x01\x20\x01(\x05R\x08clientId\x12#\n\x04uuid\x18\x02\x20\
    \x01(\x0b2\x0f.stormgate.UUIDR\x04uuid\"\xaf\x01\n\x06Player\x12#\n\x04u\
    uid\x18\x02\x20\x01(\x0b2\x0f.stormgate.UUIDR\x04uuid\x120\n\x04name\x18\
    \x03\x20\x01(\x0b2\x1c.stormgate.Player.PlayerNameR\x04name\x1aN\n\nPlay\
    erName\x12\x1a\n\x08nickname\x18\x01\x20\x01(\tR\x08nickname\x12$\n\rdis\
    criminator\x18\x02\x20\x01(\tR\rdiscriminator\"\xed\x01\n\x0fLobbyChange\
    Slot\x12=\n\x06choice\x18\x01\x20\x01(\x0b2%.stormgate.LobbyChangeSlot.S\
    lotChoiceR\x06choice\x1a\x9a\x01\n\nSlotChoice\x12Y\n\rspecific_slot\x18\
    \x02\x20\x01(\x0b22.stormgate.LobbyChangeSlot.SlotChoice.SpecificSlotH\0\
    R\x0cspecificSlot\x1a\"\n\x0cSpecificSlot\x12\x12\n\x04slot\x18\x01\x20\
    \x01(\x05R\x04slotB\r\n\x0bchoice_type\"]\n\x10LobbySetVariable\x12\x12\
    \n\x04slot\x18\x03\x20\x01(\x05R\x04slot\x12\x1f\n\x0bvariable_id\x18\
    \x04\x20\x01(\rR\nvariableId\x12\x14\n\x05value\x18\x05\x20\x01(\rR\x05v\
    alue\"\x0b\n\tStartGame\"r\n\x0ePlayerLeftGame\x120\n\x0bplayer_uuid\x18\
    \x01\x20\x01(\x0b2\x0f.stormgate.UUIDR\nplayerUuid\x12.\n\x06reason\x18\
    \x02\x20\x01(\x0e2\x16.stormgate.LeaveReasonR\x06reason\"\x93\x01\n\x12C\
    lientDisconnected\x12\x1b\n\tclient_id\x18\x01\x20\x01(\x05R\x08clientId\
    \x12.\n\x06reason\x18\x02\x20\x01(\x0e2\x16.stormgate.LeaveReasonR\x06re\
    ason\x120\n\x0bplayer_uuid\x18\x03\x20\x01(\x0b2\x0f.stormgate.UUIDR\npl\
    ayerUuid\"g\n\x10AssignPlayerSlot\x12#\n\x04uuid\x18\x01\x20\x01(\x0b2\
    \x0f.stormgate.UUIDR\x04uuid\x12\x12\n\x04slot\x18\x02\x20\x01(\x05R\x04\
    slot\x12\x1a\n\x08nickname\x18\x03\x20\x01(\tR\x08nickname\"2\n\x04UUID\
    \x12\x14\n\x05part1\x18\x01\x20\x01(\x04R\x05part1\x12\x14\n\x05part2\
    \x18\x02\x20\x01(\x04R\x05part2*I\n\tMatchType\x12\x14\n\x10UnknownMatch\
    Type\x10\0\x12\n\n\x06Custom\x10\x01\x12\r\n\tRanked1v1\x10\x02\x12\x0b\
    \n\x07Coop3vE\x10\x03*J\n\x0bLeaveReason\x12\x11\n\rUnknownReason\x10\0\
    \x12\r\n\tSurrender\x10\x01\x12\t\n\x05Leave\x10\x02\x12\x0e\n\nDisconne\
    ct\x10\x03J\x9c'\n\x07\x12\x05\0\0\x83\x01\x01\n\x08\n\x01\x0c\x12\x03\0\
    \0\x12\n\x08\n\x01\x02\x12\x03\x02\0\x12\n\x9a\x02\n\x02\x04\0\x12\x04\t\
    \0\x1d\x01\x1a\xa3\x01\x20Each\x20chunk\x20seems\x20to\x20be\x20of\x20th\
    e\x20form\x203:\x20{1:\x20{actual\x20content}}\n\x20Since\x20I\x20don't\
    \x20know\x20the\x20meaning\x20of\x20those\x20outer\x20structs\x20yet,\
    \x20I'm\x20just\x20putting\x20them\x20as\x20inline\x20messages:\n2h\x20p\
    rotobuf\x20schema\x20for\x20parsing\x20lobby\x20info\x20from\x20Stormgat\
    e\x20replays\n\x20Thanks\x20to\x20CascadeFury\x20for\x20most\x20of\x20th\
    is.\n\n\n\n\x03\x04\0\x01\x12\x03\t\x08\x13\n?\n\x04\x04\0\x02\0\x12\x03\
    \n\x04\x18\"2\x20Time\x20since\x20game\x20start\x20in\x20units\x20of\x20\
    1/1024\x20seconds\n\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\n\x04\t\n\x0c\n\
    \x05\x04\0\x02\0\x01\x12\x03\n\n\x13\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\
    \n\x16\x17\n\x0b\n\x04\x04\0\x02\x01\x12\x03\x0b\x04\x18\n\x0c\n\x05\x04\
    \0\x02\x01\x05\x12\x03\x0b\x04\t\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\
    \x0b\n\x13\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\x0b\x16\x17\n\x0c\n\x04\
    \x04\0\x03\0\x12\x04\x0c\x04\x1b\x05\n\x0c\n\x05\x04\0\x03\0\x01\x12\x03\
    \x0c\x0c\x13\n\x0e\n\x06\x04\0\x03\0\x03\0\x12\x04\r\x08\x19\t\n\x0e\n\
    \x07\x04\0\x03\0\x03\0\x01\x12\x03\r\x10\x1d\n\x10\n\x08\x04\0\x03\0\x03\
    \0\x08\0\x12\x04\x0e\x0c\x18\r\n\x10\n\t\x04\0\x03\0\x03\0\x08\0\x01\x12\
    \x03\x0e\x12\x1e\n\x0f\n\x08\x04\0\x03\0\x03\0\x02\0\x12\x03\x0f\x10+\n\
    \x10\n\t\x04\0\x03\0\x03\0\x02\0\x06\x12\x03\x0f\x10\x1a\n\x10\n\t\x04\0\
    \x03\0\x03\0\x02\0\x01\x12\x03\x0f\x1b&\n\x10\n\t\x04\0\x03\0\x03\0\x02\
    \0\x03\x12\x03\x0f)*\n\x0f\n\x08\x04\0\x03\0\x03\0\x02\x01\x12\x03\x10\
    \x105\n\x10\n\t\x04\0\x03\0\x03\0\x02\x01\x06\x12\x03\x10\x10\x1f\n\x10\
    \n\t\x04\0\x03\0\x03\0\x02\x01\x01\x12\x03\x10\x200\n\x10\n\t\x04\0\x03\
    \0\x03\0\x02\x01\x03\x12\x03\x1034\n\x0f\n\x08\x04\0\x03\0\x03\0\x02\x02\
    \x12\x03\x11\x10#\n\x10\n\t\x04\0\x03\0\x03\0\x02\x02\x06\x12\x03\x11\
    \x10\x16\n\x10\n\t\x04\0\x03\0\x03\0\x02\x02\x01\x12\x03\x11\x17\x1d\n\
    \x10\n\t\x04\0\x03\0\x03\0\x02\x02\x03\x12\x03\x11\x20\"\n\x0f\n\x08\x04\
    \0\x03\0\x03\0\x02\x03\x12\x03\x12\x101\n\x10\n\t\x04\0\x03\0\x03\0\x02\
    \x03\x06\x12\x03\x12\x10\x1f\n\x10\n\t\x04\0\x03\0\x03\0\x02\x03\x01\x12\
    \x03\x12\x20+\n\x10\n\t\x04\0\x03\0\x03\0\x02\x03\x03\x12\x03\x12.0\n\
    \x0f\n\x08\x04\0\x03\0\x03\0\x02\x04\x12\x03\x13\x103\n\x10\n\t\x04\0\
    \x03\0\x03\0\x02\x04\x06\x12\x03\x13\x10\x20\n\x10\n\t\x04\0\x03\0\x03\0\
    \x02\x04\x01\x12\x03\x13!-\n\x10\n\t\x04\0\x03\0\x03\0\x02\x04\x03\x12\
    \x03\x1302\n\x0f\n\x08\x04\0\x03\0\x03\0\x02\x05\x12\x03\x14\x10*\n\x10\
    \n\t\x04\0\x03\0\x03\0\x02\x05\x06\x12\x03\x14\x10\x19\n\x10\n\t\x04\0\
    \x03\0\x03\0\x02\x05\x01\x12\x03\x14\x1a$\n\x10\n\t\x04\0\x03\0\x03\0\
    \x02\x05\x03\x12\x03\x14')\n\x0f\n\x08\x04\0\x03\0\x03\0\x02\x06\x12\x03\
    \x15\x105\n\x10\n\t\x04\0\x03\0\x03\0\x02\x06\x06\x12\x03\x15\x10\x1e\n\
    \x10\n\t\x04\0\x03\0\x03\0\x02\x06\x01\x12\x03\x15\x1f/\n\x10\n\t\x04\0\
    \x03\0\x03\0\x02\x06\x03\x12\x03\x1524\n\x0f\n\x08\x04\0\x03\0\x03\0\x02\
    \x07\x12\x03\x16\x10<\n\x10\n\t\x04\0\x03\0\x03\0\x02\x07\x06\x12\x03\
    \x16\x10\"\n\x10\n\t\x04\0\x03\0\x03\0\x02\x07\x01\x12\x03\x16#6\n\x10\n\
    \t\x04\0\x03\0\x03\0\x02\x07\x03\x12\x03\x169;\n\x0f\n\x08\x04\0\x03\0\
    \x03\0\x02\x08\x12\x03\x17\x109\n\x10\n\t\x04\0\x03\0\x03\0\x02\x08\x06\
    \x12\x03\x17\x10\x20\n\x10\n\t\x04\0\x03\0\x03\0\x02\x08\x01\x12\x03\x17\
    !3\n\x10\n\t\x04\0\x03\0\x03\0\x02\x08\x03\x12\x03\x1768\n\r\n\x06\x04\0\
    \x03\0\x02\0\x12\x03\x1a\x08\"\n\x0e\n\x07\x04\0\x03\0\x02\0\x06\x12\x03\
    \x1a\x08\x15\n\x0e\n\x07\x04\0\x03\0\x02\0\x01\x12\x03\x1a\x16\x1d\n\x0e\
    \n\x07\x04\0\x03\0\x02\0\x03\x12\x03\x1a\x20!\n\x0b\n\x04\x04\0\x02\x02\
    \x12\x03\x1c\x04\x16\n\x0c\n\x05\x04\0\x02\x02\x06\x12\x03\x1c\x04\x0b\n\
    \x0c\n\x05\x04\0\x02\x02\x01\x12\x03\x1c\x0c\x11\n\x0c\n\x05\x04\0\x02\
    \x02\x03\x12\x03\x1c\x14\x15\n+\n\x02\x04\x01\x12\x04\x20\0%\x01\x1a\x1f\
    \x203\x20-\x20Map\x20identifier\x20+\x20RNG\x20seed\n\n\n\n\x03\x04\x01\
    \x01\x12\x03\x20\x08\x12\n\x0b\n\x04\x04\x01\x02\0\x12\x03!\x03\x19\n\
    \x0c\n\x05\x04\x01\x02\0\x05\x12\x03!\x03\t\n\x0c\n\x05\x04\x01\x02\0\
    \x01\x12\x03!\n\x14\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03!\x17\x18\n\x0b\
    \n\x04\x04\x01\x02\x01\x12\x03\"\x03\x17\n\x0c\n\x05\x04\x01\x02\x01\x05\
    \x12\x03\"\x03\t\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03\"\n\x12\n\x0c\n\
    \x05\x04\x01\x02\x01\x03\x12\x03\"\x15\x16\nF\n\x04\x04\x01\x02\x02\x12\
    \x03#\x03\x16\"9\x20Is\x20different\x20every\x20lobby,\x20so\x20probably\
    \x20some\x20kind\x20of\x20seed\n\n\x0c\n\x05\x04\x01\x02\x02\x05\x12\x03\
    #\x03\x08\n\x0c\n\x05\x04\x01\x02\x02\x01\x12\x03#\t\x11\n\x0c\n\x05\x04\
    \x01\x02\x02\x03\x12\x03#\x14\x15\n\x0b\n\x04\x04\x01\x02\x03\x12\x03$\
    \x03\x1c\n\x0c\n\x05\x04\x01\x02\x03\x06\x12\x03$\x03\x0c\n\x0c\n\x05\
    \x04\x01\x02\x03\x01\x12\x03$\r\x17\n\x0c\n\x05\x04\x01\x02\x03\x03\x12\
    \x03$\x1a\x1b\n\n\n\x02\x05\0\x12\x04'\0,\x01\n\n\n\x03\x05\0\x01\x12\
    \x03'\x05\x0e\n\x0b\n\x04\x05\0\x02\0\x12\x03(\x03\x18\n\x0c\n\x05\x05\0\
    \x02\0\x01\x12\x03(\x03\x13\n\x0c\n\x05\x05\0\x02\0\x02\x12\x03(\x16\x17\
    \n\x0b\n\x04\x05\0\x02\x01\x12\x03)\x03\x0e\n\x0c\n\x05\x05\0\x02\x01\
    \x01\x12\x03)\x03\t\n\x0c\n\x05\x05\0\x02\x01\x02\x12\x03)\x0c\r\n\x0b\n\
    \x04\x05\0\x02\x02\x12\x03*\x03\x11\n\x0c\n\x05\x05\0\x02\x02\x01\x12\
    \x03*\x03\x0c\n\x0c\n\x05\x05\0\x02\x02\x02\x12\x03*\x0f\x10\n\x0b\n\x04\
    \x05\0\x02\x03\x12\x03+\x03\x0f\n\x0c\n\x05\x05\0\x02\x03\x01\x12\x03+\
    \x03\n\n\x0c\n\x05\x05\0\x02\x03\x02\x12\x03+\r\x0e\n\x88\x01\n\x02\x04\
    \x02\x12\x040\03\x01\x1a|\x204\x20-\x20sent\x20by\x20server\x20after\x20\
    each\x20player\x20connects?\n\x20in\x20new\x20co-op\x20replay\x20it's\
    \x20the\x20only\x20way\x20to\x20link\x20a\x20player\x20to\x20their\x20cl\
    ient_id.\n\n\n\n\x03\x04\x02\x01\x12\x030\x08\x17\n\x0b\n\x04\x04\x02\
    \x02\0\x12\x031\x04\x18\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x031\x04\t\n\
    \x0c\n\x05\x04\x02\x02\0\x01\x12\x031\n\x13\n\x0c\n\x05\x04\x02\x02\0\
    \x03\x12\x031\x16\x17\n\x0b\n\x04\x04\x02\x02\x01\x12\x032\x04\x12\n\x0c\
    \n\x05\x04\x02\x02\x01\x06\x12\x032\x04\x08\n\x0c\n\x05\x04\x02\x02\x01\
    \x01\x12\x032\t\r\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x032\x10\x11\n9\n\
    \x02\x04\x03\x12\x046\0=\x01\x1a-\x2012\x20-\x20Sent\x20by\x20a\x20playe\
    r\x20when\x20they\x20join\x20a\x20game\n\n\n\n\x03\x04\x03\x01\x12\x036\
    \x08\x0e\n\x0b\n\x04\x04\x03\x02\0\x12\x037\x04\x12\n\x0c\n\x05\x04\x03\
    \x02\0\x06\x12\x037\x04\x08\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x037\t\r\n\
    \x0c\n\x05\x04\x03\x02\0\x03\x12\x037\x10\x11\n\x0c\n\x04\x04\x03\x03\0\
    \x12\x048\x04;\x05\n\x0c\n\x05\x04\x03\x03\0\x01\x12\x038\x0c\x16\n\r\n\
    \x06\x04\x03\x03\0\x02\0\x12\x039\x08\x1c\n\x0e\n\x07\x04\x03\x03\0\x02\
    \0\x05\x12\x039\x08\x0e\n\x0e\n\x07\x04\x03\x03\0\x02\0\x01\x12\x039\x0f\
    \x17\n\x0e\n\x07\x04\x03\x03\0\x02\0\x03\x12\x039\x1a\x1b\n\r\n\x06\x04\
    \x03\x03\0\x02\x01\x12\x03:\x08!\n\x0e\n\x07\x04\x03\x03\0\x02\x01\x05\
    \x12\x03:\x08\x0e\n\x0e\n\x07\x04\x03\x03\0\x02\x01\x01\x12\x03:\x0f\x1c\
    \n\x0e\n\x07\x04\x03\x03\0\x02\x01\x03\x12\x03:\x1f\x20\n\x0b\n\x04\x04\
    \x03\x02\x01\x12\x03<\x04\x18\n\x0c\n\x05\x04\x03\x02\x01\x06\x12\x03<\
    \x04\x0e\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x03<\x0f\x13\n\x0c\n\x05\
    \x04\x03\x02\x01\x03\x12\x03<\x16\x17\n\xc8\x01\n\x02\x04\x04\x12\x04B\0\
    M\x01\x1a\xbb\x01\x2013\x20-\x20Sent\x20when\x20player\x20changes\x20slo\
    t\x20(leave/enter),\x20note\x20that\x20SlotChoice\n\x20contains\x20eithe\
    r\x20a\x20request\x20for\x20a\x20specific\x20slot,\x20or\x20what\x20I\
    \x20assume\x20is\x20a\x20\"next\n\x20slot\x20available\",\x20slot\x20255\
    \x20is\x20observer\n\n\n\n\x03\x04\x04\x01\x12\x03B\x08\x17\n\x0c\n\x04\
    \x04\x04\x03\0\x12\x04C\x04J\x05\n\x0c\n\x05\x04\x04\x03\0\x01\x12\x03C\
    \x0c\x16\n\x0e\n\x06\x04\x04\x03\0\x03\0\x12\x04D\x08F\t\n\x0e\n\x07\x04\
    \x04\x03\0\x03\0\x01\x12\x03D\x10\x1c\n\x0f\n\x08\x04\x04\x03\0\x03\0\
    \x02\0\x12\x03E\x0c\x1b\n\x10\n\t\x04\x04\x03\0\x03\0\x02\0\x05\x12\x03E\
    \x0c\x11\n\x10\n\t\x04\x04\x03\0\x03\0\x02\0\x01\x12\x03E\x12\x16\n\x10\
    \n\t\x04\x04\x03\0\x03\0\x02\0\x03\x12\x03E\x19\x1a\n\x0e\n\x06\x04\x04\
    \x03\0\x08\0\x12\x04G\x08I\t\n\x0e\n\x07\x04\x04\x03\0\x08\0\x01\x12\x03\
    G\x0e\x19\n\r\n\x06\x04\x04\x03\0\x02\0\x12\x03H\x0c+\n\x0e\n\x07\x04\
    \x04\x03\0\x02\0\x06\x12\x03H\x0c\x18\n\x0e\n\x07\x04\x04\x03\0\x02\0\
    \x01\x12\x03H\x19&\n\x0e\n\x07\x04\x04\x03\0\x02\0\x03\x12\x03H)*\n\x0b\
    \n\x04\x04\x04\x02\0\x12\x03L\x04\x1a\n\x0c\n\x05\x04\x04\x02\0\x06\x12\
    \x03L\x04\x0e\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03L\x0f\x15\n\x0c\n\x05\
    \x04\x04\x02\0\x03\x12\x03L\x18\x19\n\xe9\x01\n\x02\x04\x05\x12\x04S\0W\
    \x01\x1a\xdc\x01\x2015\x20-\x20Sent\x20when\x20a\x20player\x20slot\x20ha\
    s\x20a\x20variable\x20changed\n\x20Var\x20374945738:\x20Type,\x200\x20=\
    \x20Closed,\x201\x20=\x20Human,\x202\x20=\x20AI\n\x20Var\x202952722564:\
    \x20Faction,\x200\x20=\x20Vanguard,\x201\x20=\x20Infernals\n\x20Var\x206\
    55515685:\x20AIType,\x200\x20=\x20Peaceful,\x201\x20=\x20Junior,\x202\
    \x20=\x20Senior\n\n\n\n\x03\x04\x05\x01\x12\x03S\x08\x18\n\x0b\n\x04\x04\
    \x05\x02\0\x12\x03T\x04\x13\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x03T\x04\t\
    \n\x0c\n\x05\x04\x05\x02\0\x01\x12\x03T\n\x0e\n\x0c\n\x05\x04\x05\x02\0\
    \x03\x12\x03T\x11\x12\n\x0b\n\x04\x04\x05\x02\x01\x12\x03U\x04\x1b\n\x0c\
    \n\x05\x04\x05\x02\x01\x05\x12\x03U\x04\n\n\x0c\n\x05\x04\x05\x02\x01\
    \x01\x12\x03U\x0b\x16\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x03U\x19\x1a\n\
    \x0b\n\x04\x04\x05\x02\x02\x12\x03V\x04\x15\n\x0c\n\x05\x04\x05\x02\x02\
    \x05\x12\x03V\x04\n\n\x0c\n\x05\x04\x05\x02\x02\x01\x12\x03V\x0b\x10\n\
    \x0c\n\x05\x04\x05\x02\x02\x03\x12\x03V\x13\x14\n\x82\x01\n\x02\x04\x06\
    \x12\x04Z\0[\x01\x1av\x2018\x20-\x20\"Start\x20Game\"\x20Sent\x20by\x20p\
    layers\x20after\x20second\x20ReadyUp,\x20that\x20probably\x20indicates\
    \x20player\x20finished\x20loading\x20into\x20the\x20map\n\n\n\n\x03\x04\
    \x06\x01\x12\x03Z\x08\x11\n\n\n\x02\x05\x01\x12\x04^\0c\x01\n\n\n\x03\
    \x05\x01\x01\x12\x03^\x05\x10\n\x0b\n\x04\x05\x01\x02\0\x12\x03_\x03\x15\
    \n\x0c\n\x05\x05\x01\x02\0\x01\x12\x03_\x03\x10\n\x0c\n\x05\x05\x01\x02\
    \0\x02\x12\x03_\x13\x14\n\x20\n\x04\x05\x01\x02\x01\x12\x03`\x03\x11\"\
    \x13\x20Player\x20surrenders\n\n\x0c\n\x05\x05\x01\x02\x01\x01\x12\x03`\
    \x03\x0c\n\x0c\n\x05\x05\x01\x02\x01\x02\x12\x03`\x0f\x10\n\x97\x01\n\
    \x04\x05\x01\x02\x02\x12\x03a\x03\r\"\x89\x01\x20Player\x20leaves\x20gam\
    e\x20normally\x20(game\x20ended\x20earlier,\x20if\x20this\x20is\x20the\
    \x20first\x20PlayerLeftGame\x20message,\x20the\x20outcome\x20should\x20b\
    e\x20considered\x20unknown)\n\n\x0c\n\x05\x05\x01\x02\x02\x01\x12\x03a\
    \x03\x08\n\x0c\n\x05\x05\x01\x02\x02\x02\x12\x03a\x0b\x0c\n%\n\x04\x05\
    \x01\x02\x03\x12\x03b\x03\x12\"\x18\x20Player\x20lost\x20connection\n\n\
    \x0c\n\x05\x05\x01\x02\x03\x01\x12\x03b\x03\r\n\x0c\n\x05\x05\x01\x02\
    \x03\x02\x12\x03b\x10\x11\n;\n\x02\x04\x07\x12\x04f\0i\x01\x1a/\x2025\
    \x20-\x20When\x20a\x20player\x20exits\x20the\x20game/disconnects\n\n\n\n\
    \x03\x04\x07\x01\x12\x03f\x08\x16\n\x0b\n\x04\x04\x07\x02\0\x12\x03g\x04\
    \x19\n\x0c\n\x05\x04\x07\x02\0\x06\x12\x03g\x04\x08\n\x0c\n\x05\x04\x07\
    \x02\0\x01\x12\x03g\t\x14\n\x0c\n\x05\x04\x07\x02\0\x03\x12\x03g\x17\x18\
    \n\x0b\n\x04\x04\x07\x02\x01\x12\x03h\x04\x1b\n\x0c\n\x05\x04\x07\x02\
    \x01\x06\x12\x03h\x04\x0f\n\x0c\n\x05\x04\x07\x02\x01\x01\x12\x03h\x10\
    \x16\n\x0c\n\x05\x04\x07\x02\x01\x03\x12\x03h\x19\x1a\n@\n\x02\x04\x08\
    \x12\x04l\0p\x01\x1a4\x2031\x20-\x20sent\x20by\x20the\x20server\x20after\
    \x20a\x20client\x20disconnects\n\n\n\n\x03\x04\x08\x01\x12\x03l\x08\x1a\
    \n\x0b\n\x04\x04\x08\x02\0\x12\x03m\x04\x18\n\x0c\n\x05\x04\x08\x02\0\
    \x05\x12\x03m\x04\t\n\x0c\n\x05\x04\x08\x02\0\x01\x12\x03m\n\x13\n\x0c\n\
    \x05\x04\x08\x02\0\x03\x12\x03m\x16\x17\n\x0b\n\x04\x04\x08\x02\x01\x12\
    \x03n\x04\x1b\n\x0c\n\x05\x04\x08\x02\x01\x06\x12\x03n\x04\x0f\n\x0c\n\
    \x05\x04\x08\x02\x01\x01\x12\x03n\x10\x16\n\x0c\n\x05\x04\x08\x02\x01\
    \x03\x12\x03n\x19\x1a\n\x0b\n\x04\x04\x08\x02\x02\x12\x03o\x04\x19\n\x0c\
    \n\x05\x04\x08\x02\x02\x06\x12\x03o\x04\x08\n\x0c\n\x05\x04\x08\x02\x02\
    \x01\x12\x03o\t\x14\n\x0c\n\x05\x04\x08\x02\x02\x03\x12\x03o\x17\x18\nX\
    \n\x02\x04\t\x12\x04t\0x\x01\x1aL\x2037\x20-\x20AssignPlayer\x20(done\
    \x20by\x20server\x20as\x20pl=64)\n\x20Appears\x20only\x20in\x20ladder\
    \x20games?\n\n\n\n\x03\x04\t\x01\x12\x03t\x08\x18\n\x0b\n\x04\x04\t\x02\
    \0\x12\x03u\x04\x12\n\x0c\n\x05\x04\t\x02\0\x06\x12\x03u\x04\x08\n\x0c\n\
    \x05\x04\t\x02\0\x01\x12\x03u\t\r\n\x0c\n\x05\x04\t\x02\0\x03\x12\x03u\
    \x10\x11\n\x0b\n\x04\x04\t\x02\x01\x12\x03v\x04\x13\n\x0c\n\x05\x04\t\
    \x02\x01\x05\x12\x03v\x04\t\n\x0c\n\x05\x04\t\x02\x01\x01\x12\x03v\n\x0e\
    \n\x0c\n\x05\x04\t\x02\x01\x03\x12\x03v\x11\x12\n\x0b\n\x04\x04\t\x02\
    \x02\x12\x03w\x04\x18\n\x0c\n\x05\x04\t\x02\x02\x05\x12\x03w\x04\n\n\x0c\
    \n\x05\x04\t\x02\x02\x01\x12\x03w\x0b\x13\n\x0c\n\x05\x04\t\x02\x02\x03\
    \x12\x03w\x16\x17\n\xae\x02\n\x02\x04\n\x12\x06\x80\x01\0\x83\x01\x01\
    \x1a\x9f\x02\x20UUIDs\x20are\x20encoded\x20as\x202\x20varints.\n\x20To\
    \x20recover\x20the\x20original\x20UUID,\x20encode\x20these\x20as\x20unsi\
    gned\x2064-bit\x20big-endian\n\x20integers\x20and\x20concatenate\x20the\
    \x20resulting\x20bitstrings;\x20or\x20in\x20python:\n\x20\x20\x20\x20\
    \x20uuid.UUID(bytes=struct.pack(\">QQ\",\x20part1,\x20part2))\n\x20or\
    \x20equivalently\n\x20\x20\x20\x20\x20uuid.UUID(int=(part1\x20<<\x2064)\
    \x20|\x20part2)\n\n\x0b\n\x03\x04\n\x01\x12\x04\x80\x01\x08\x0c\n\x0c\n\
    \x04\x04\n\x02\0\x12\x04\x81\x01\x04\x15\n\r\n\x05\x04\n\x02\0\x05\x12\
    \x04\x81\x01\x04\n\n\r\n\x05\x04\n\x02\0\x01\x12\x04\x81\x01\x0b\x10\n\r\
    \n\x05\x04\n\x02\0\x03\x12\x04\x81\x01\x13\x14\n\x0c\n\x04\x04\n\x02\x01\
    \x12\x04\x82\x01\x04\x15\n\r\n\x05\x04\n\x02\x01\x05\x12\x04\x82\x01\x04\
    \n\n\r\n\x05\x04\n\x02\x01\x01\x12\x04\x82\x01\x0b\x10\n\r\n\x05\x04\n\
    \x02\x01\x03\x12\x04\x82\x01\x13\x14b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(16);
            messages.push(ReplayChunk::generated_message_descriptor_data());
            messages.push(MapDetails::generated_message_descriptor_data());
            messages.push(ClientConnected::generated_message_descriptor_data());
            messages.push(Player::generated_message_descriptor_data());
            messages.push(LobbyChangeSlot::generated_message_descriptor_data());
            messages.push(LobbySetVariable::generated_message_descriptor_data());
            messages.push(StartGame::generated_message_descriptor_data());
            messages.push(PlayerLeftGame::generated_message_descriptor_data());
            messages.push(ClientDisconnected::generated_message_descriptor_data());
            messages.push(AssignPlayerSlot::generated_message_descriptor_data());
            messages.push(UUID::generated_message_descriptor_data());
            messages.push(replay_chunk::Wrapper::generated_message_descriptor_data());
            messages.push(replay_chunk::wrapper::ReplayContent::generated_message_descriptor_data());
            messages.push(player::PlayerName::generated_message_descriptor_data());
            messages.push(lobby_change_slot::SlotChoice::generated_message_descriptor_data());
            messages.push(lobby_change_slot::slot_choice::SpecificSlot::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(2);
            enums.push(MatchType::generated_enum_descriptor_data());
            enums.push(LeaveReason::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
